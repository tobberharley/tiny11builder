name: Build tiny11 ISO (bootable, auto-index)

on:
  workflow_dispatch:
    inputs:
      iso_url:
        description: "Direct download URL to official Windows 11 ISO (x64 or ARM64)"
        required: true
      edition_order:
        description: "Comma-separated preference (matches Name): Pro,Professional,Enterprise,Education,Home"
        required: false
        default: "Pro,Professional,Enterprise,Education,Home"

jobs:
  build:
    runs-on: windows-latest
    timeout-minutes: 360

    steps:
      - name: Checkout this repo
        uses: actions/checkout@v4

      - name: Checkout tiny11builder
        uses: actions/checkout@v4
        with:
          repository: tobberharley/tiny11builder
          ref: main
          path: tiny11builder

      - name: Download Windows ISO
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $isoUrl = '${{ github.event.inputs.iso_url }}'
          $out = Join-Path $PWD 'win11.iso'
          Invoke-WebRequest -Uri $isoUrl -OutFile $out
          Write-Host "Downloaded to: $out"

      - name: Mount ISO
        id: mount_iso
        shell: pwsh
        run: |
          $isoPath = Join-Path $PWD 'win11.iso'
          $di = Mount-DiskImage -ImagePath $isoPath -StorageType ISO -PassThru
          Start-Sleep -Seconds 3
          $vol = (Get-DiskImage -ImagePath $isoPath | Get-Volume | Where-Object DriveLetter).DriveLetter
          if (-not $vol) { throw 'Failed to get mounted ISO drive letter.' }
          "ISO_DRIVE=$vol" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding ascii -Append
          Write-Host "ISO mounted at $vol:"

      - name: Detect edition index
        id: detect_index
        shell: pwsh
        env:
          ISO_DRV: ${{ steps.mount_iso.outputs.ISO_DRIVE }}
          EDITION_ORDER: ${{ github.event.inputs.edition_order }}
        run: |
          $iso = "$env:ISO_DRV`:"
          $wim = Join-Path $iso 'sources\install.wim'
          $esd = Join-Path $iso 'sources\install.esd'
          $imageFile = if (Test-Path $wim) { $wim } elseif (Test-Path $esd) { $esd } else { throw "No install.wim/esd found in $iso\sources" }
          $lines = & dism /English /Get-WimInfo /WimFile:$imageFile
          if ($LASTEXITCODE -ne 0) { throw "DISM failed to read $imageFile" }
          $entries = @()
          $curr = @{}
          foreach ($line in $lines) {
            if ($line -match '^\s*Index\s*:\s*(\d+)\s*$') {
              if ($curr.Count) { $entries += [pscustomobject]$curr; $curr=@{} }
              $curr.Index = [int]$matches[1]
            } elseif ($line -match '^\s*Name\s*:\s*(.+)$') {
              $curr.Name = $matches[1].Trim()
            } elseif ($line -match '^\s*Architecture\s*:\s*(.+)$') {
              $curr.Arch = $matches[1].Trim()
            }
          }
          if ($curr.Count) { $entries += [pscustomobject]$curr }
          if (-not $entries) { throw "No images found in $imageFile" }
          $pref = if ([string]::IsNullOrWhiteSpace($env:EDITION_ORDER)) { 'Pro,Professional,Enterprise,Education,Home' } else { $env:EDITION_ORDER }
          $prefList = $pref.Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }
          $chosen = $null
          foreach ($p in $prefList) {
            $chosen = $entries | Where-Object { $_.Name -match [regex]::Escape($p) } | Select-Object -First 1
            if ($chosen) { break }
          }
          if (-not $chosen) { $chosen = $entries | Select-Object -First 1 }
          "SKU_INDEX=$($chosen.Index)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding ascii -Append
          Write-Host "Chosen image index: $($chosen.Index) ($($chosen.Name))"

      - name: Create scratch drive S:
        shell: pwsh
        run: |
          $scr = Join-Path $PWD 'scratch.vhdx'
          $diskpart = @'
          create vdisk file="$SCR" maximum=40960 type=expandable
          select vdisk file="$SCR"
          attach vdisk
          create partition primary
          format fs=ntfs quick label=scratch
          assign letter=S
          exit
'@
          $diskpart = $diskpart.Replace('$SCR',$scr)
          Set-Content -Path diskpart.txt -Value $diskpart -Encoding ascii
          diskpart /s diskpart.txt

      - name: Build tiny11 ISO
        shell: pwsh
        working-directory: tiny11builder
        env:
          ISO_DRV: ${{ steps.mount_iso.outputs.ISO_DRIVE }}
          SKU_INDEX: ${{ steps.detect_index.outputs.SKU_INDEX }}
        run: |
          Set-ExecutionPolicy Bypass -Scope Process -Force
          $args = @('-ISO', "$env:ISO_DRV", '-SCRATCH', 'S', '-Index', "$env:SKU_INDEX")
          Write-Host "tiny11maker args: $($args -join ' ')"
          .\tiny11maker.ps1 @args
          if (-not (Test-Path '.\tiny11.iso')) {
            throw 'tiny11.iso not found.'
          }

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: tiny11-iso
          path: tiny11builder/tiny11.iso

      - name: Cleanup
        if: always()
        shell: pwsh
        run: |
          $scr = Join-Path $PWD 'scratch.vhdx'
          $detach = @'
          select vdisk file="$SCR"
          detach vdisk
          exit
'@
          $detach = $detach.Replace('$SCR',$scr)
          Set-Content -Path diskpart-detach.txt -Value $detach -Encoding ascii
          diskpart /s diskpart-detach.txt | Out-Null
          $isoPath = Join-Path $PWD 'win11.iso'
          if (Test-Path $isoPath) { Dismount-DiskImage -ImagePath $isoPath -ErrorAction SilentlyContinue }
